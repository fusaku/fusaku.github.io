<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<title>视频播放 - 字幕播放器</title>
<style>
  body {
    font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    margin: 0;
    padding: 20px;
    background: #1a1a1a;
    color: #fff;
    min-height: 100vh;
  }
  
  #header {
    background: #2a2a2a;
    padding: 15px 20px;
    border-radius: 8px;
    margin-bottom: 20px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  }
  
  #back-button {
    background: #1890ff;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    text-decoration: none;
    display: inline-flex;
    align-items: center;
    gap: 8px;
    transition: background 0.2s;
  }
  #back-button:hover { background: #0050b3; }
  
  #video-title {
    font-size: 18px;
    font-weight: 600;
    color: #fff;
    margin: 0;
    flex: 1;
    text-align: center;
    padding: 0 20px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  
  #subtitle-controls { 
    display: flex; 
    align-items: center; 
    gap: 15px; 
  }
  
  #subtitle-toggle {
    background: #52c41a;
    color: white;
    border: none;
    padding: 8px 12px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    transition: background 0.2s;
  }
  #subtitle-toggle:hover { background: #389e0d; }
  #subtitle-toggle.disabled { 
    background: #666; 
    cursor: not-allowed; 
  }
  
  #subtitle-status { 
    font-size: 12px; 
    color: #999; 
  }
  
  #video-container {
    max-width: 1200px;
    margin: 0 auto;
    position: relative;
    background: #000;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 4px 16px rgba(0,0,0,0.4);
  }
  
  .video-wrapper {
    position: relative;
    width: 100%;
    height: 0;
    padding-bottom: 56.25%; /* 16:9 aspect ratio */
  }
  
  #youtube-player, #fallback-iframe {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border: none;
  }
  
  #subtitle-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    z-index: 50;
  }
  
  .subtitle-line {
    position: absolute;
    color: #fff;
    font-size: 18px;
    font-weight: 600;
    text-shadow: 
      -1px -1px 0 #000,
      1px -1px 0 #000,
      -1px 1px 0 #000,
      1px 1px 0 #000,
      0 0 3px rgba(0,0,0,0.8);
    white-space: pre-wrap;
    line-height: 1.2;
    max-width: 90%;
    word-wrap: break-word;
  }
  
  .subtitle-line.bottom {
    bottom: 60px;
    left: 50%;
    transform: translateX(-50%);
    text-align: center;
  }
  
  .subtitle-line.top {
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    text-align: center;
  }
  
  .subtitle-line.left {
    left: 20px;
    top: 50%;
    transform: translateY(-50%);
    text-align: left;
  }
  
  .subtitle-line.right {
    right: 20px;
    top: 50%;
    transform: translateY(-50%);
    text-align: right;
  }
  
  #loading, #error {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    z-index: 100;
    background: rgba(0,0,0,0.8);
    padding: 20px;
    border-radius: 8px;
  }
  
  #error { 
    background: #ff4d4f; 
    color: white;
  }
  
  .hidden { display: none !important; }
  
  .fallback-notice {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(255, 193, 7, 0.9);
    color: #000;
    padding: 8px 16px;
    border-radius: 4px;
    font-size: 12px;
    z-index: 60;
  }
  
  .loading-spinner {
    border: 3px solid #f3f3f3;
    border-top: 3px solid #1890ff;
    border-radius: 50%;
    width: 30px;
    height: 30px;
    animation: spin 1s linear infinite;
    margin: 0 auto 10px;
  }
  
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  
  /* ASS字幕样式效果 */
  .subtitle-bold { font-weight: bold; }
  .subtitle-italic { font-style: italic; }
  .subtitle-underline { text-decoration: underline; }
  .subtitle-strikeout { text-decoration: line-through; }
</style>
</head>
<body>

<div id="header">
  <a href="index.html" id="back-button">← 返回列表</a>
  <h1 id="video-title">加载中...</h1>
  <div id="subtitle-controls">
    <span id="subtitle-status">字幕: 加载中...</span>
    <button id="subtitle-toggle" class="disabled">显示字幕</button>
  </div>
</div>

<div id="video-container">
  <div class="video-wrapper">
    <div id="loading">
      <div class="loading-spinner"></div>
      正在加载视频...<br>
      <small id="loading-status">初始化播放器</small>
    </div>
    
    <div id="error" class="hidden">
      <h3>加载失败</h3>
      <p id="error-message">无法加载视频</p>
      <button onclick="retryLoad()" style="margin-top: 10px; padding: 8px 16px; background: #1890ff; color: white; border: none; border-radius: 4px; cursor: pointer;">重试</button>
    </div>
    
    <div id="youtube-player" class="hidden"></div>
    <iframe id="fallback-iframe" class="hidden" allowfullscreen></iframe>
    
    <div id="subtitle-overlay"></div>
  </div>
</div>

<script>
let currentVideoId = '';
let subtitles = [];
let subtitlesVisible = true;
let player = null;
let updateInterval = null;
let loadingTimeout = null;
let usingFallback = false;
let apiReady = false;

function getVideoIdFromUrl() {
  const params = new URLSearchParams(window.location.search);
  return params.get('v');
}

// 改进的ASS字幕解析
function parseASSSubtitles(assContent) {
  const lines = assContent.split('\n');
  const subtitleLines = [];
  let inEvents = false;
  
  for (let line of lines) {
    line = line.trim();
    if (line === '[Events]') { 
      inEvents = true; 
      continue; 
    }
    if (line.startsWith('[') && line !== '[Events]') { 
      inEvents = false; 
      continue; 
    }
    
    if (inEvents && line.startsWith('Dialogue:')) {
      const parts = line.split(',');
      if (parts.length >= 10) {
        const startTime = parseASSTime(parts[1].trim());
        const endTime = parseASSTime(parts[2].trim());
        const style = parts[3].trim();
        const text = parts.slice(9).join(',').replace(/\\N/g, '\n').trim();
        
        if (text && startTime !== null && endTime !== null) {
          subtitleLines.push({ 
            start: startTime, 
            end: endTime, 
            text: text,
            style: style
          });
        }
      }
    }
  }
  
  return subtitleLines.sort((a, b) => a.start - b.start);
}

function parseASSTime(timeStr) {
  const match = timeStr.match(/(\d+):(\d+):(\d+)\.(\d+)/);
  if (!match) return null;
  return parseInt(match[1]) * 3600 + parseInt(match[2]) * 60 + 
         parseInt(match[3]) + parseInt(match[4]) / 100;
}

// 改进的字幕加载
async function loadSubtitles(videoId) {
  try {
    console.log('Loading subtitles for:', videoId);
    const response = await fetch(`./subtitles/${videoId}.ass`);
    
    if (!response.ok) {
      throw new Error(`字幕文件不存在 (${response.status})`);
    }
    
    const assContent = await response.text();
    console.log('ASS content loaded, length:', assContent.length);
    
    subtitles = parseASSSubtitles(assContent);
    console.log('Parsed subtitles:', subtitles.length);
    
    if (subtitles.length > 0) {
      document.getElementById('subtitle-status').textContent = `字幕: ${subtitles.length} 行`;
      document.getElementById('subtitle-toggle').classList.remove('disabled');
      document.getElementById('subtitle-toggle').textContent = '隐藏字幕';
      return true;
    } else {
      throw new Error('字幕文件为空或格式不正确');
    }
  } catch (error) {
    console.error('Subtitle loading error:', error);
    document.getElementById('subtitle-status').textContent = '字幕: 无';
    document.getElementById('subtitle-toggle').classList.add('disabled');
    document.getElementById('subtitle-toggle').textContent = '无字幕';
    subtitles = [];
    subtitlesVisible = false;
    return false;
  }
}

// 改进的字幕渲染，支持ASS标签
// 改进的字幕渲染，支持弹幕样式
function displayCurrentSubtitle(currentTime) {
  const overlay = document.getElementById('subtitle-overlay');
  
  if (!subtitlesVisible || subtitles.length === 0) {
    overlay.innerHTML = '';
    return;
  }
  
  const currentSubs = subtitles.filter(sub => 
    currentTime >= sub.start && currentTime <= sub.end
  );
  
  // 清除不再显示的字幕
  const existingSubtitles = overlay.querySelectorAll('.danmaku-subtitle');
  existingSubtitles.forEach(el => {
    const startTime = parseFloat(el.dataset.startTime);
    const endTime = parseFloat(el.dataset.endTime);
    if (currentTime < startTime || currentTime > endTime) {
      el.remove();
    }
  });
  
  currentSubs.forEach((sub, index) => {
    // 检查是否已经存在这个字幕元素
    const existingId = `subtitle-${sub.start}-${sub.end}-${lineIndex}`;
    if (overlay.querySelector(`[data-subtitle-id="${existingId}"]`)) {
      return; // 已存在，跳过
    }
    
    const lines = sub.text.split('\n');
    lines.forEach((line, lineIndex) => {
      if (!line.trim()) return;
      
      const div = document.createElement('div');
      div.className = 'danmaku-subtitle';
      div.dataset.subtitleId = existingId;
      div.dataset.startTime = sub.start;
      div.dataset.endTime = sub.end;
      
      // 解析ASS标签
      let cleanText = line;
      let moveData = null;
      
      // 提取移动标签
      const moveMatch = line.match(/\\move\((\d+),(\d+),(\d+),(\d+)\)/);
      const alphaMatch = line.match(/\\alpha&H([0-9A-Fa-f]+)&/);
      
      if (moveMatch) {
        moveData = {
          x1: parseInt(moveMatch[1]),
          y1: parseInt(moveMatch[2]),
          x2: parseInt(moveMatch[3]),
          y2: parseInt(moveMatch[4])
        };
      }
      
      // 设置弹幕样式
      div.style.position = 'absolute';
      div.style.color = '#fff';
      div.style.fontSize = '16px';
      div.style.fontWeight = '600';
      div.style.textShadow = '-1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000, 0 0 3px rgba(0,0,0,0.8)';
      div.style.whiteSpace = 'nowrap';
      div.style.pointerEvents = 'none';
      div.style.zIndex = '100';
      
      // 设置透明度
      if (alphaMatch) {
        const alpha = parseInt(alphaMatch[1], 16);
        div.style.opacity = (255 - alpha) / 255;
      }
      
      if (moveData) {
        // 弹幕动画：从右到左移动
        const containerWidth = overlay.offsetWidth || 1200;
        const duration = sub.end - sub.start;
        
        // 将ASS坐标系统转换为CSS坐标
        // ASS默认分辨率是640x360，需要按比例缩放
        const scaleX = containerWidth / 640;
        const scaleY = (overlay.offsetHeight || 675) / 360;
        
        const startX = moveData.x1 * scaleX;
        const startY = moveData.y1 * scaleY;
        const endX = moveData.x2 * scaleX;
        const endY = moveData.y2 * scaleY;
        
        // 设置初始位置
        div.style.left = `${startX}px`;
        div.style.top = `${startY}px`;
        div.style.transition = `all ${duration}s linear`;
        
        // 开始动画
        requestAnimationFrame(() => {
          div.style.left = `${endX}px`;
          div.style.top = `${endY}px`;
        });
      } else {
        // 如果没有移动标签，默认作为普通弹幕处理
        const containerWidth = overlay.offsetWidth || 1200;
        const duration = sub.end - sub.start;
        const yPos = 20 + (index + lineIndex) * 25; // 错开显示
        
        div.style.left = `${containerWidth}px`;
        div.style.top = `${yPos}px`;
        div.style.transition = `left ${duration}s linear`;
        
        // 开始弹幕动画
        requestAnimationFrame(() => {
          div.style.left = `-200px`;
        });
      }
      
      // 处理文本样式标签
      cleanText = line.replace(/\{[^}]*\}/g, (match) => {
        if (match.includes('\\b1')) div.style.fontWeight = 'bold';
        if (match.includes('\\i1')) div.style.fontStyle = 'italic';
        if (match.includes('\\u1')) div.style.textDecoration = 'underline';
        if (match.includes('\\s1')) div.style.textDecoration = 'line-through';
        
        // 颜色标签
        const colorMatch = match.match(/\\c&H([0-9A-Fa-f]{6})&/);
        if (colorMatch) {
          const color = colorMatch[1];
          const r = parseInt(color.substr(4, 2), 16);
          const g = parseInt(color.substr(2, 2), 16);
          const b = parseInt(color.substr(0, 2), 16);
          div.style.color = `rgb(${r}, ${g}, ${b})`;
        }
        
        return '';
      });
      
      div.textContent = cleanText.trim();
      overlay.appendChild(div);
    });
  });
}

async function fetchVideoTitle(videoId) {
  try {
    const res = await fetch(`https://noembed.com/embed?url=https://www.youtube.com/watch?v=${videoId}`);
    if (res.ok) {
      const data = await res.json();
      return data.title || '视频播放';
    }
  } catch (error) {
    console.error('Failed to fetch video title:', error);
  }
  return '视频播放';
}

function updateLoadingStatus(status) {
  const el = document.getElementById('loading-status');
  if (el) el.textContent = status;
  console.log('Loading status:', status);
}

function showSuccess() {
  document.getElementById('loading').classList.add('hidden');
  document.getElementById('error').classList.add('hidden');
  
  if (usingFallback) {
    document.getElementById('fallback-iframe').classList.remove('hidden');
    const notice = document.createElement('div');
    notice.className = 'fallback-notice';
    notice.textContent = '使用备用播放器 - 字幕可能不完全同步';
    document.getElementById('video-container').appendChild(notice);
  } else {
    document.getElementById('youtube-player').classList.remove('hidden');
  }
  
  if (loadingTimeout) {
    clearTimeout(loadingTimeout);
    loadingTimeout = null;
  }
  
  console.log('Player loaded successfully, using fallback:', usingFallback);
}

// 改进的YouTube API处理
function onYouTubeIframeAPIReady() {
  console.log('YouTube API ready');
  apiReady = true;
  if (currentVideoId) {
    initializeYouTubePlayer();
  }
}

function onPlayerReady(event) {
  console.log('YouTube player ready');
  showSuccess();
  startSubtitleUpdate();
}

function onPlayerStateChange(event) {
  console.log('Player state changed:', event.data);
  if (event.data === YT.PlayerState.PLAYING) {
    startSubtitleUpdate();
  }
}

function onPlayerError(event) {
  console.error('YouTube player error:', event.data);
  tryFallbackPlayer();
}

// 改进的播放器初始化
function initializeYouTubePlayer() {
  if (!apiReady || !currentVideoId) {
    console.log('API or video ID not ready');
    return;
  }
  
  try {
    updateLoadingStatus('创建YouTube播放器...');
    console.log('Creating YouTube player for video:', currentVideoId);
    
    player = new YT.Player('youtube-player', {
      height: '100%',
      width: '100%',
      videoId: currentVideoId,
      playerVars: {
        'playsinline': 1,
        'autoplay': 1,
        'controls': 1,
        'rel': 0,
        'modestbranding': 1,
        'fs': 1,
        'enablejsapi': 1
      },
      events: {
        'onReady': onPlayerReady,
        'onStateChange': onPlayerStateChange,
        'onError': onPlayerError
      }
    });
    
    // 增加超时时间到10秒
    loadingTimeout = setTimeout(() => {
      console.log('YouTube player timeout, trying fallback');
      tryFallbackPlayer();
    }, 10000);
    
  } catch (error) {
    console.error('Error creating YouTube player:', error);
    tryFallbackPlayer();
  }
}

function tryFallbackPlayer() {
  if (usingFallback) return;
  
  console.log('Using fallback player');
  usingFallback = true;
  updateLoadingStatus('使用备用播放器...');
  
  if (loadingTimeout) {
    clearTimeout(loadingTimeout);
    loadingTimeout = null;
  }
  
  const fb = document.getElementById('fallback-iframe');
  fb.src = `https://www.youtube.com/embed/${currentVideoId}?autoplay=1&controls=1&rel=0&modestbranding=1&fs=1`;
  fb.onload = () => {
    showSuccess();
    startBasicSubtitleUpdate();
  };
}

function startBasicSubtitleUpdate() {
  if (subtitles.length === 0) return;
  
  console.log('Starting basic subtitle update');
  let startTime = Date.now();
  
  if (updateInterval) clearInterval(updateInterval);
  updateInterval = setInterval(() => {
    const elapsed = (Date.now() - startTime) / 1000;
    displayCurrentSubtitle(elapsed);
  }, 500);
}

function startSubtitleUpdate() {
  if (subtitles.length === 0) return;
  
  console.log('Starting YouTube subtitle update');
  if (updateInterval) clearInterval(updateInterval);
  
  updateInterval = setInterval(() => {
    if (player && typeof player.getCurrentTime === 'function') {
      try {
        const currentTime = player.getCurrentTime();
        displayCurrentSubtitle(currentTime);
      } catch (error) {
        console.error('Error getting current time:', error);
      }
    }
  }, 100);
}

function showError(message) {
  console.error('Showing error:', message);
  document.getElementById('error-message').textContent = message;
  document.getElementById('error').classList.remove('hidden');
  document.getElementById('loading').classList.add('hidden');
}

function retryLoad() { 
  location.reload(); 
}

function toggleSubtitles() {
  const btn = document.getElementById('subtitle-toggle');
  if (btn.classList.contains('disabled') || subtitles.length === 0) return;
  
  subtitlesVisible = !subtitlesVisible;
  btn.textContent = subtitlesVisible ? '隐藏字幕' : '显示字幕';
  
  if (!subtitlesVisible) {
    document.getElementById('subtitle-overlay').innerHTML = '';
  }
  
  console.log('Subtitles toggled:', subtitlesVisible);
}

// 改进的API加载
function loadYouTubeAPI() {
  return new Promise((resolve, reject) => {
    if (window.YT && window.YT.Player) { 
      console.log('YouTube API already loaded');
      apiReady = true;
      resolve(); 
      return; 
    }
    
    console.log('Loading YouTube API...');
    window.onYouTubeIframeAPIReady = () => {
      console.log('YouTube API callback triggered');
      apiReady = true;
      resolve();
    };
    
    const script = document.createElement('script');
    script.src = 'https://www.youtube.com/iframe_api';
    script.async = true;
    script.onload = () => {
      console.log('YouTube API script loaded');
    };
    script.onerror = () => {
      console.error('Failed to load YouTube API script');
      reject(new Error('YouTube API脚本加载失败'));
    };
    document.head.appendChild(script);
    
    // 增加API加载超时时间
    setTimeout(() => {
      if (!apiReady) {
        console.error('YouTube API initialization timeout');
        reject(new Error('YouTube API初始化超时'));
      }
    }, 15000);
  });
}

async function initializePage() {
  try {
    currentVideoId = getVideoIdFromUrl();
    if (!currentVideoId) {
      throw new Error('未提供视频ID');
    }
    
    console.log('Initializing page for video:', currentVideoId);
    
    updateLoadingStatus('加载视频信息...');
    
    // 并行加载视频标题和字幕
    const [title] = await Promise.all([
      fetchVideoTitle(currentVideoId), 
      loadSubtitles(currentVideoId)
    ]);
    
    document.getElementById('video-title').textContent = title;
    document.title = `${title} - 视频播放`;
    
    updateLoadingStatus('加载YouTube API...');
    
    try {
      await loadYouTubeAPI();
      // 确保API准备就绪后再初始化播放器
      if (apiReady) {
        initializeYouTubePlayer();
      }
    } catch (error) {
      console.error('YouTube API loading failed:', error);
      setTimeout(() => tryFallbackPlayer(), 1000);
    }
    
  } catch (err) {
    console.error('Page initialization error:', err);
    showError(err.message);
  }
}

// 清理资源
window.addEventListener('beforeunload', () => {
  if (updateInterval) clearInterval(updateInterval);
  if (loadingTimeout) clearTimeout(loadingTimeout);
  if (player && typeof player.destroy === 'function') { 
    try { 
      player.destroy(); 
    } catch (error) {
      console.error('Error destroying player:', error);
    }
  }
});

// 页面加载完成后初始化
document.addEventListener('DOMContentLoaded', () => {
  console.log('DOM loaded, initializing...');
  
  initializePage();
  
  // 绑定事件
  document.getElementById('subtitle-toggle').addEventListener('click', toggleSubtitles);
  
  // 键盘快捷键
  document.addEventListener('keydown', (e) => {
    if ((e.key === 's' || e.key === 'S') && subtitles.length > 0) { 
      e.preventDefault(); 
      toggleSubtitles(); 
    } else if (e.key === 'Escape') { 
      e.preventDefault(); 
      window.location.href = 'index.html'; 
    }
  });
});
</script>
</body>
</html>